# Computer Science - it's what's you do.

This week, we were told about quite a few facets of computer science. Algorithms, Data Structures, and Big O Notation. These items are barely scratching the surface of what actually encompasses computer science, but I'd like to share what I've learned from class and from my own research on these topics.

### Lets start with Recursion

![Image of Fibonacci's Dog](https://mir-s3-cdn-cf.behance.net/project_modules/max_1200/e6a06f36963657.57305b5170b0b.gif)

The concept of recursion is simple on its face. Basically, you call a function until you don't. This process starts at the beginning, or the root. When you pose a question, the proocess begins looking for the answer through all of the levels of information until it finds the answer, then travels back through maintaining all of the relevant information so that it can present the answer to you. From what I can tell, everything from IPs, to addresses will use recursion.

### A litte about Algorithms
![Image of a while loop](https://goo.gl/wuv9oL#center)

The word sounds complex, but is it? Sure, it can be, but all it really is is a set of instructions. A problem solving process that allows you to find a solution within a certain amount of time.

Ever baked a cake? If you put the eggs in the oven before adding them to the rest of the ingredients, you would have a terrible cake. You need to follow the instructions or the order of operations in order to accomplish this task. How long does it take to bake a cake? If you follow the instructions properly and with a pre-heated oven at 350&deg;you'll have a cake within about 45 minutes.

In computer science, you accomplish tasks in a very similar way. Following instructions using predetermined parameters will allow you to accomplish a lot of tasks within certain amount of time.
Algorithms can be difficult, but just like any skill, with practice, they begin to open up and make sense.

### Big O Notation and the bit I know

![Image of Big O Notation](https://goo.gl/rBEPaM)

How efficient does something work in its worst case? That is the gist of Big O Notation. This process is here to help you strive to build the most efficient version of your coding structure. There are multiple ways to do everything, but Big O doesn't care. Its only concerned with the worst possible outcome. It reminds me of the old saying "you're only as strong as your weakest link".
